Traffic Control
===============
TC（Traffic Control）是Linux中用来进行流量控制的工具，tc利用队列规定建立数据包队列，并定义了队列中数据包得发送方式，从而实现对流量的控制。  
  
TC对流量进行控制，主要依赖于以下三个概念：

* qdisc（排队规则）

		qdisc是流量控制的基础，内核如果需要通过某个网络接口发送数据包，它会按照接口配置的qdisc将数据包加入队列中。内核会尽可能多的从qdisc中取出数据报，然后交给网络适配器。

* class（分类）

		一些qdisc可以包含一些类，通过将qdisc细分，可以为进入队列的数据包进行排队，再通过设置各种类数据包的里对次序，可以设置网络数据流量的优先级。

* filter（过滤器）：

		filter用于为书包分类，决定数据包进入何种qdisc队列。
		
###QDISC  
qdisc分为两类：不可分类队列规则和可分类队列规则。  

#####不可分类队列规则：

* SFQ：随机公平队列。SFQ针对一个TCP会话或者UDP流，流量被分成相当多数量的FIFO队列中，每个队列对应一个会话。数据按照简单轮转的方式发送, 每个会话都按顺序得到发送机会。
    
   `使用这种方式的好处是：每个会话均可得到流量发送的机会，不会存在一个会话长时间占用发送`  
   
    SFQ的"随机", 是因通过是使用一个散列算法，把所有的会话映射到有限的几个队列中去。因为使用了散列，所以可能多个会话分配在同一个队列里，从而需要共享发包的机会，也就是共享带宽。
    
    `SFQ只有在数据发生拥堵时，才会起作用，当网络情况良好，数据未发生拥堵时，SFQ并不会起什么作用`

* TBF：令牌桶。只允许以不超过事先设定的速率到来的数据包通过，但可能允许短暂突发流量朝过设定值。  

  TBF原理： TBF用一个缓冲器（桶），它被一些Token以一定速率填充。当一个数据报到来时，它会消耗其中一个Token，然后通过。
		1. 当数据流速率小于Token填充的速率时，每个数据数据包消耗一个Token，然后无延迟的通过。
		2. 当数据流速率小于Token填充速率时，通过队列的数据包只会消耗一部分令牌，剩下的令牌会在桶   里积累下来，直到桶被填满，这样当发生突发传输时（发送数据速率大于Token填充速率），可以通过消耗积累的Token，得到满足。
		3.数据流持续以大于Token速率到达队列，这时Token会被消耗完。当数据爆无Token对应时，数据的发送会停止一段时间，如果持续发送会导致丢包，这样可以对数据的速率进行调整。
		
#####可分类队列规则
如果有多种数据流需要进行区别对待，分类的队列规定就非常有用了。一旦数据报进入一个分类的队列规定，他就得被送往某一个类中。对数据包进行分类的时filter，filter会返回一个决定，qdisc会根据这个决定将数据包送入相应的class进行排队，每个class可以再次使用它们的filter进行进一步的分类。直到不需要分类为止，数据报便进入了该class包含的qdisc进行排队。
		
* Qdisc Family：root， handle，siblings， parent
	> 每块网卡都有一个root qdisc
	> 每个qdisc都需要指定一个句柄（handle），以便以后的配置可以引用到这个qdisc
	> handle由两部分组成 major:minor
	
* PRIO 分类优先算法，队列规定并不进行整形，它仅仅根据你配置的过滤器把流量进一步细分。
  当数据包进入PRIO队列规定后，将根据你给定的过滤器设置选择一个类。缺省情况下有三个类，这些类仅包含纯FIFO队列规定而没有更多的内部结构。可以把它们替换成任何队列规定。每当有一个数据包需要出队时，首先处理:1类。只有当标号更小的类中没有需要处理的包时，才会处理标号大的类。
  
* CBQ
  CBQ 的工作机制是确认链路的闲置时间足够长 , 以达到降低链路实际带宽的目的。为此，它要计算两个数据包的平均发送间隔。
  （？？？略麻烦  没太看明白）

* HTB
  分层的TBF


  
 
	




 
